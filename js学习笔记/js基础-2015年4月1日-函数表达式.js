(function () {
    /*
    函数声明和函数表达式之间唯一的区别是：函数声明具有函数声明提升。即在同一个执行环境中，即使函数声明是在最底部，仍然可以在执行环境中的
    刚开始调用该函数

    在严格模式下调用函数属性arguments的callee属性会引起错误，因此在使用递归方法时会出错
  */

    function example(num) {
        if (num <= 1)
            return 1;
        return num * arguments.callee(num - 1);         //这里会抛出错误
    }

    /*
        替代方法是使用命名函数表达式来调用
    */

    function example() {
        var factorial = (function f(num) {
            if (num <= 1)
                return 1;
            return num * f(num - 1);
        });

        var anotherFactorial = factorial;
        factorial = null;
        anotherFactorial(10);               //正确，不会抛出错误

    }


    /*
        闭包

        在创建函数的时候，会先创建一个包含外部执行环境变量对象的作用域链，这个作用域链被保存在内部的[[scope]]属性中。在执行这个函数时，会为
        函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。然后再创建当前的活动对象（对象变量）并
        推入执行环境作用域链的前端。在执行函数时，其活动对象会自动取得两个特殊的变量：this和arguments。函数在搜索这两个特殊的变量时只会搜索到
        其活动变量为止，并不会搜索外部的包含环境


        由上面这一段话得出，在函数的内部返回函数，内部函数如果包含外部函数中的变量时。在执行外部函数的代码并返回内部函数时，内部函数中已经创建
        好了一个包含外部执行环境变量对象的作用域链了。因为函数在执行完毕后，执行环境和他的作用域链会被销毁，一般情况下执行环境相对应的变量对象
        也会被销毁。因为执行环境销毁后就没有任何对象会在引用该变量对象。但是由于返回的内部函数的作用域链引用了外部环境中的变量，那就相当于
        内部函数引用了外部的变量对象，所以当执行这个返回来的匿名函数时，就可以沿着其作用域链一步一步向上搜索到外部的变量对象。

        具体图示看 《javascript 高级程序设计第三版》的 199 页图7-2
    */

})();
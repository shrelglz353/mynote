(function () {

    /*
        变量

        ECMAScript5中基本类型：Undefined,Null,String,Int,Boolean
        基本类型是按值访问，引用类型按引用访问

        将一个基本类型的值复制到另一个变量时，复制的是改值的一个拷贝，而将一个引用类型的变量赋值到另外一个变量时赋值的是该变量的
        引用。
    */

    function example() {
        var obj = {
            name: 'zhangsan',
            age: 19
        };

        var obj2 = obj;

        obj2.name = 'lisi';

        console.log(obj.name);      //lisi
    }

    /*
        ECMAScript在给方法传递变量是始终是按值传递。基本类型传递时传递的是值的一个拷贝，引用类型传递时复制的是引用的拷贝。



        类型检测

        在对基本类型进行检测的时候可以使用 typeof 操作符进行检测，在对引用类型进行检测时可以使用 instanceof, 使用instanceof时会在要检测
        对象的原型链上查找给定类型，如果原型链中有则返回true 否则返回false
    */

    function example2() {
        console.log(typeof 1);      //number
        console.log(typeof 'a');    //string

        var obj = {};
        console.log(obj instanceof Object);     //true
    }

    /*
        执行环境和作用域

        执行环境是我们代码运行时所依赖的一个环境，其中包含自定义的变量、对象等。每个执行环境都有一个相对的变量对象，环境中所有的属性
        都保存在该对象中。我们无法访问这个对象，但解析器在执行的时候可以访问该变量

        全局的执行环境是window对象，因此所有的全局的变量和对象都是作为window的属性和方法创建的。
        某个执行环境中的代码执行完毕后，该执行环境即被销毁，保存在其中的所有变量和对象也同时被销毁。


        每个函数都有自己的执行环境，当执行流进入到一个新的执行环境中的时候会创建用于搜索变量和函数的作用域链，并将当前执行环境的变量对象放置在次作用域链的前端
        ，当前的执行环境在最开始只保存arguments一个变量。作用域链的下一个变量对象来自于当前执行环境的包含环境，即外部环境，再下一个变量
        对象来自下一个包含环境，知道全局的变量对象。全局变量对象始终是作用域链中的最后一个对象。

        标识符解析是沿着作用域链一级一级的解析，直到找到标识符为止，如果作用域链中有多个相同的标识符，则查找最近的一个。如果直到最后一个
        变量对象都没有找到标识符，就会抛出错误
    */

    var num = 11;
    function example3() {
        if (num % 2 == 1)
            console.log(1);
        else
            console.log(0);
    }

    example3();

    /*
        在函数example3的作用域链中包含两个变量对象，它自己的和全局的变量对象。正是因为可以沿着作用域链向后搜索所以才可以访问外部的变量

        有两种方法可以延长作用域链 with和 try...catch。with语句会将指定的对象添加到作用于链的前端。try...catch语句中的catch会创建一个
        新的对象变量，其中包含错误对象及描述等。


    */

    function example4() {
        var arg = '?a=b';

        with (window.location) {
            var url = href + arg;
        }

        return url;
    }

    /*
        在example4中，with语句引用了window对象的location属性，因此变量对象中包含了所有location的方法和属性，然后此变量对象被添加到
        作用域链的前端。因此在with语句内部可以直接调用location的属性。在with语句内部声明了一个变量url，由于with语句只是给作用域链前端
        添加一个对象变量，并不会影响执行环境。所以可以在函数中访问with语句中的变量。

        ECMAScript没有块级作用域。使用var声明的变量会被添加到最近的执行环境。对于函数内部，使用var声明的变量将会被添加到函数的执行环境，
        对于with语句，最近的执行环境则是调用with语句的环境。




        垃圾收集

        ECMAScript的垃圾收集机制有两个：标记清除和引用计数

        标记清除：当变量进入环境时，就将这个变量标记为“进入环境”，被标记为“进入环境”的变量永远不可能被清除，当变量厉害环境后将其
        标记为“离开环境”，垃圾收集器每隔一段时间会清除一次被标记为“离开环境”的变量

        引用计数：当声明一个变量后将一个引用类型的值赋给该变量后，它的引用计数就加1。如果该应用类型的引用计数为0时，垃圾收集器在下次启动
        时会清理该变量。因为引用计数策略会造成重复引用，他的计数永远都不会被清0.所以建议在不使用时手动给变量赋null
    */

    function example5() {
        var obj = {
            name: 'zhangsan',
            friend: obj1
        };

        var obj1 = {
            name: 'lisi',
            friend: obj
        };

        obj.friend = null;
        obj1.friend = null;
    }

    /*
        在example5中，由于obj和obj1的两个属性互相引用，所以即使example方法执行完毕清理了变量obj和obj1，但这两个对象依然各自有1个对方的引用
        所以引用计数永远不会变成0.所以要在最后不使用该属性是手动去掉引用，然后垃圾收集器在下一次启动时才会清理这两个引用对象占用的内存空间。

    */

})();